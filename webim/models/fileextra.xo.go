// Package models contains the types for schema 'custmchat'.
package models

// Code generated by xo. DO NOT EDIT.

import (
	"fmt"
	"strings"
	"time"
)

// FileExtra represents a row from 'custmchat.file_extra'.
type FileExtra struct {
	EntID      string    `json:"ent_id"`      // ent_id
	Name       string    `json:"name"`        // name
	Type       string    `json:"type"`        // type
	Size       int       `json:"size"`        // size
	UploadTime time.Time `json:"upload_time"` // upload_time
	ExpireAt   time.Time `json:"expire_at"`   // expire_at
}

func FileExtrasByName(db XODB, name string) ([]*FileExtra, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`ent_id, name, type, size, upload_time, expire_at ` +
		`FROM custmchat.file_extra ` +
		`WHERE name = ?`

	q, err := db.Query(sqlstr, name)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	var res []*FileExtra
	for q.Next() {
		fe := FileExtra{}

		// scan
		err = q.Scan(&fe.EntID, &fe.Name, &fe.Type, &fe.Size, &fe.UploadTime, &fe.ExpireAt)
		if err != nil {
			return nil, err
		}

		res = append(res, &fe)
	}
	if err := q.Err(); err != nil {
		return res, err
	}

	return res, nil
}

func (f *FileExtra) Insert(db XODB) error {
	var err error

	// sql insert query, primary key must be provided
	const sqlstr = `INSERT INTO custmchat.file_extra (` +
		`ent_id, name, type, size, upload_time, expire_at` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?` +
		`)`

	_, err = db.Exec(sqlstr, f.EntID, f.Name, f.Type, f.Size, f.UploadTime, f.ExpireAt)
	if err != nil {
		return err
	}

	return nil
}

func FileExtrasByNames(db XODB, names []string) (extras []*FileExtra, err error) {
	if len(names) == 0 {
		return []*FileExtra{}, nil
	}

	sqlstr := `SELECT ` +
		`ent_id, name, type, size, upload_time, expire_at ` +
		`FROM custmchat.file_extra ` +
		`WHERE name IN (%s)`

	var args []interface{}
	var placeHolders []string
	for _, name := range names {
		placeHolders = append(placeHolders, "?")
		args = append(args, name)
	}

	sqlstr = fmt.Sprintf(sqlstr, strings.Join(placeHolders, ","))
	q, err := db.Query(sqlstr, args...)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	var res []*FileExtra
	for q.Next() {
		fe := FileExtra{}

		// scan
		err = q.Scan(&fe.EntID, &fe.Name, &fe.Type, &fe.Size, &fe.UploadTime, &fe.ExpireAt)
		if err != nil {
			return nil, err
		}

		res = append(res, &fe)
	}

	return res, nil
}
