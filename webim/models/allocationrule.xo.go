// Package new_models contains the types for schema 'custmchat'.
package models

// Code generated by xo. DO NOT EDIT.

var (
	// OrderTakeTurnsAllocation 按客服顺序轮流
	OrderTakeTurnsAllocation = "roundrobin"

	// OrderPriorityAllocation 按客服顺序优先
	OrderPriorityAllocation = "rank_order"

	// ConversationNumAllocation 按会话数分配
	ConversationNumAllocation = "least_conv"

	AllocationRuleTypeMap = map[string]bool{
		OrderTakeTurnsAllocation:  true,
		OrderPriorityAllocation:   true,
		ConversationNumAllocation: true,
	}
)

// AllocationRule represents a row from 'custmchat.allocation_rule'.
type AllocationRule struct {
	ID       string `json:"id"`        // id
	EntID    string `json:"ent_id"`    // ent_id
	RuleType string `json:"rule_type"` // rule_type

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the AllocationRule exists in the database.
func (ar *AllocationRule) Exists() bool {
	return ar._exists
}

// Deleted provides information if the AllocationRule has been deleted from the database.
func (ar *AllocationRule) Deleted() bool {
	return ar._deleted
}

// Insert inserts the AllocationRule to the database.
func (ar *AllocationRule) Insert(db XODB) error {
	var err error

	// sql insert query, primary key must be provided
	const sqlstr = `INSERT INTO custmchat.allocation_rule (` +
		`id, ent_id, rule_type` +
		`) VALUES (` +
		`?, ?, ?` +
		`) ` +
		`ON DUPLICATE KEY UPDATE rule_type=VALUES(rule_type)`

	// run query
	XOLog(sqlstr, ar.ID, ar.EntID, ar.RuleType)
	_, err = db.Exec(sqlstr, ar.ID, ar.EntID, ar.RuleType)
	if err != nil {
		return err
	}

	return nil
}

// Update updates the AllocationRule in the database.
func (ar *AllocationRule) Update(db XODB) error {
	var err error

	const sqlstr = `UPDATE custmchat.allocation_rule SET ` +
		`ent_id = ?, rule_type = ?` +
		` WHERE id = ?`

	// run query
	XOLog(sqlstr, ar.EntID, ar.RuleType, ar.ID)
	_, err = db.Exec(sqlstr, ar.EntID, ar.RuleType, ar.ID)
	return err
}

// Save saves the AllocationRule to the database.
func (ar *AllocationRule) Save(db XODB) error {
	if ar.Exists() {
		return ar.Update(db)
	}

	return ar.Insert(db)
}

// Delete deletes the AllocationRule from the database.
func (ar *AllocationRule) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !ar._exists {
		return nil
	}

	// if deleted, bail
	if ar._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM custmchat.allocation_rule WHERE id = ?`

	// run query
	XOLog(sqlstr, ar.ID)
	_, err = db.Exec(sqlstr, ar.ID)
	if err != nil {
		return err
	}

	// set deleted
	ar._deleted = true

	return nil
}

// AllocationRuleByID retrieves a row from 'custmchat.allocation_rule' as a AllocationRule.
//
// Generated from index 'allocation_rule_id_pkey'.
func AllocationRuleByID(db XODB, id string) (*AllocationRule, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, ent_id, rule_type ` +
		`FROM custmchat.allocation_rule ` +
		`WHERE id = ?`

	// run query
	XOLog(sqlstr, id)
	ar := AllocationRule{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&ar.ID, &ar.EntID, &ar.RuleType)
	if err != nil {
		return nil, err
	}

	return &ar, nil
}

// AllocationRuleByEntID retrieves a row from 'custmchat.allocation_rule' as a AllocationRule.
//
// Generated from index 'ent_id'.
func AllocationRuleByEntID(db XODB, entID string) (rule string, err error) {

	// sql query
	const sqlstr = `SELECT ` +
		`allocation_rule ` +
		`FROM custmchat.enterprise ` +
		`WHERE id = ?`

	err = db.QueryRow(sqlstr, entID).Scan(&rule)
	if err != nil {
		return "", err
	}

	return
}
