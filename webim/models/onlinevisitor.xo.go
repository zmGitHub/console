// Package models contains the types for schema 'custmchat'.
package models

// Code generated by xo. DO NOT EDIT.

import (
	"fmt"
	"strings"
	"time"
)

// OnlineVisitor represents a row from 'custmchat.online_visitors'.
type OnlineVisitor struct {
	EntID     string    `json:"ent_id"`     // ent_id
	TraceID   string    `json:"trace_id"`   // trace_id
	CreatedAt time.Time `json:"created_at"` // created_at
	UpdatedAt time.Time `json:"updated_at"` // updated_at
}

func OnlineVisitorByEntIDTraceID(db XODB, entID, traceID string) (*OnlineVisitor, error) {
	var err error

	const sqlstr = `SELECT ` +
		`ent_id, trace_id, created_at, updated_at ` +
		`FROM custmchat.online_visitors ` +
		`WHERE ent_id = ? AND trace_id = ?`
	ov := &OnlineVisitor{}
	err = db.QueryRow(sqlstr, entID, traceID).Scan(&ov.EntID, &ov.TraceID, &ov.CreatedAt, &ov.UpdatedAt)
	if err != nil {
		return nil, err
	}

	return ov, nil
}

// OnlineVisitorsByTraceID retrieves a row from 'custmchat.online_visitors' as a OnlineVisitor.
//
// Generated from index 'idx_trace'.
func OnlineVisitorsByTraceID(db XODB, traceID string) ([]*OnlineVisitor, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`ent_id, trace_id, created_at, updated_at ` +
		`FROM custmchat.online_visitors ` +
		`WHERE trace_id = ?`

	// run query
	XOLog(sqlstr, traceID)
	q, err := db.Query(sqlstr, traceID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*OnlineVisitor{}
	for q.Next() {
		ov := OnlineVisitor{}

		// scan
		err = q.Scan(&ov.EntID, &ov.TraceID, &ov.CreatedAt, &ov.UpdatedAt)
		if err != nil {
			return nil, err
		}

		res = append(res, &ov)
	}

	return res, nil
}

func OnlineVisitorsByTraceIDs(db XODB, traceIDs []string) (map[string][]*OnlineVisitor, error) {
	if len(traceIDs) == 0 {
		return map[string][]*OnlineVisitor{}, nil
	}

	var err error

	// sql query
	sqlstr := `SELECT ` +
		`ent_id, trace_id, created_at, updated_at ` +
		`FROM custmchat.online_visitors ` +
		`WHERE trace_id IN (%s)`

	var args []interface{}
	var placeHolders []string
	for _, id := range traceIDs {
		args = append(args, id)
		placeHolders = append(placeHolders, "?")
	}

	q, err := db.Query(fmt.Sprintf(sqlstr, strings.Join(placeHolders, ",")), args...)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	var m = map[string][]*OnlineVisitor{}
	for q.Next() {
		ov := &OnlineVisitor{}

		err = q.Scan(&ov.EntID, &ov.TraceID, &ov.CreatedAt, &ov.UpdatedAt)
		if err != nil {
			return nil, err
		}

		v, ok := m[ov.TraceID]
		if ok {
			v = append(v, ov)
			m[ov.TraceID] = v
			continue
		}

		m[ov.TraceID] = []*OnlineVisitor{ov}
	}

	return m, nil
}
